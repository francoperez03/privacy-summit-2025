# Cheating Attempts and Protections in the ZK Circuit (Stage 2 — Merkle Membership)

This document outlines potential attacks against a Merkle **membership** circuit and how the recommended design blocks them.\
Goal: prove that a private `leaf` belongs to a Merkle tree committed by a **public **``.

---

## 1) Fake inclusion with forged siblings

**Attacker's idea:** “I'll craft sibling nodes and directions to make my value reach the root.”

**Where it fails:**

```rust
assert(digest == root);
```

The circuit recomputes the root from `leaf`, `path`, and the traversal order. Any wrong sibling or order produces a different digest.

✅ Blocks **fake membership**.

---

## 2) Selector manipulation (left/right order)

**Attacker's idea:** “I’ll flip selector bits so that a wrong path still matches.”

**Where it fails:**

- If the circuit **derives selectors from **``, their order is fixed by the bit pattern:
  ```rust
  // dir = ((index >> i) & 1) == 1
  ```
- If the circuit **accepts **``** as input**, add strict checks:
  - Length fixed to the tree depth.
  - `selector[i] ∈ {true, false}` (no arbitrary Field).
  - Optional: assert consistency with a provided `index`.

✅ Blocks **path traversal tampering**.

---

## 3) Use a stale or unauthorized root

**Attacker's idea:** “I’ll prove membership against an old root (or one I chose) where my leaf exists.”

**Where it fails:**

- The circuit only checks that `digest == root`. It cannot know if `root` is current or authorized.
- **Mitigation is off-circuit:** the verifier must supply and enforce the **latest/valid root** (e.g., epoch-based, on-chain, or signed snapshot).

✅ Prevented by **verifier-side freshness policy**, not circuit logic.

---

## 4) Copy someone else’s proof (cross-user replay)

**Attacker's idea:** “I’ll reuse a valid proof generated by another user.”

**Where it fails (if hardened leaf):**

- If the leaf includes the user binding, e.g.:
  ```text
  leaf = H("MEMBERSHIP", app_id, group_id, account_id, attr, version)
  ```
  then the proof binds to a specific `account_id`. Copying the proof for a different account won’t verify.

**If the leaf is not bound to the user:** the attack **may succeed**. Bind the leaf to `account_id` or introduce a context‑bound nullifier (see #6).

✅ Blocks **cross-user replay** when **leaf is user-bound**.

---

## 5) Ambiguous / generic leaves

**Attacker's idea:** “I’ll use a very short or generic value for the leaf so it matches multiple trees/usages.”

**Where it fails (with hardening):**

- Use **domain separation** and strong leaf structure:
  ```text
  leaf = H("MEMBERSHIP", app_id, group_id, account_id, attr, version)
  ```
  This prevents a leaf built for one purpose from being valid in another.

✅ Blocks **leaf reuse across domains**.

---

## 6) Reuse the same proof multiple times (consume-once)

**Attacker's idea:** “I’ll present the same membership proof multiple times to claim multiple benefits.”

**Where it fails (if consume-once is required):**

- Introduce a **nullifier** derived inside the circuit and make it public:
  ```text
  nullifier = H("NF_MEMB", nsk, leaf, app_id, group_id, epoch_id, request_id)
  ```
- The verifier keeps a set of seen `nullifier`s and **rejects duplicates**.

✅ Blocks **double-use** / **intra-context replay**.

---

## 7) Build a parallel tree with the same root

**Attacker's idea:** “I’ll construct another tree with the same root and claim inclusion.”

**Where it fails:**

- With a secure hash (Poseidon2) and structured leaves, finding a collision root is infeasible.
- The real risk is **authorization** of the root, not collision.

✅ Security relies on **collision resistance** and **authorized root management**.

---

### Summary

| Threat                              | Blocked by                                                 |
| ----------------------------------- | ---------------------------------------------------------- |
| Fake siblings / forged path         | `digest == root` recomputation                             |
| Selector manipulation               | Derive from `index`, or validate `selector` strictly       |
| Stale / unauthorized root           | Verifier-side policy: latest/signed/epoch root             |
| Copy another user's proof           | User-bound leaf (`account_id` in leaf)                     |
| Ambiguous leaf / cross-domain reuse | Domain-separated structured leaf                           |
| Double-use / intra-context replay   | Public **nullifier** + verifier keeps a set of seen values |
| Parallel tree / same root           | Poseidon2 security + root authorization                    |

---

### Minimal vs. Hardened vs. Consume-once

- **Minimal (teaching):** `assert(compute_root(leaf, path, selector) == root)`
- **Hardened:** structured leaf with domain tags; derive selector from `index`; enforce tree depth; bind to `app_id/group_id/version/epoch`
- **Consume-once:** add `nullifier` and require verifier-side **seen set**

